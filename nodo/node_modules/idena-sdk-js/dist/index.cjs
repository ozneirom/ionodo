/*!
 * idena-sdk-js v0.1.0
 * (c) idena
 * Released under the MIT License.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Long = require('long');
var _m0 = require('protobufjs/minimal.js');
var BN = require('bn.js');
var Decimal = require('decimal.js');
var sha3 = require('js-sha3');
var secp256k1 = require('secp256k1');
var axios = require('axios');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Long__default = /*#__PURE__*/_interopDefaultLegacy(Long);
var _m0__default = /*#__PURE__*/_interopDefaultLegacy(_m0);
var BN__default = /*#__PURE__*/_interopDefaultLegacy(BN);
var Decimal__default = /*#__PURE__*/_interopDefaultLegacy(Decimal);
var sha3__default = /*#__PURE__*/_interopDefaultLegacy(sha3);
var secp256k1__default = /*#__PURE__*/_interopDefaultLegacy(secp256k1);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);

/* eslint-disable */
function createBaseProtoTransaction() {
    return { data: undefined, signature: new Uint8Array(), useRlp: false };
}
const ProtoTransaction = {
    encode(message, writer = _m0__default["default"].Writer.create()) {
        if (message.data !== undefined) {
            ProtoTransaction_Data.encode(message.data, writer.uint32(10).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
            writer.uint32(18).bytes(message.signature);
        }
        if (message.useRlp === true) {
            writer.uint32(24).bool(message.useRlp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0__default["default"].Reader ? input : new _m0__default["default"].Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtoTransaction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = ProtoTransaction_Data.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                case 3:
                    message.useRlp = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseProtoTransaction();
        message.data =
            object.data !== undefined && object.data !== null
                ? ProtoTransaction_Data.fromPartial(object.data)
                : undefined;
        message.signature = (_a = object.signature) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.useRlp = (_b = object.useRlp) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseProtoTransaction_Data() {
    return {
        nonce: 0,
        epoch: 0,
        type: 0,
        to: new Uint8Array(),
        amount: new Uint8Array(),
        maxFee: new Uint8Array(),
        tips: new Uint8Array(),
        payload: new Uint8Array(),
    };
}
const ProtoTransaction_Data = {
    encode(message, writer = _m0__default["default"].Writer.create()) {
        if (message.nonce !== 0) {
            writer.uint32(8).uint32(message.nonce);
        }
        if (message.epoch !== 0) {
            writer.uint32(16).uint32(message.epoch);
        }
        if (message.type !== 0) {
            writer.uint32(24).uint32(message.type);
        }
        if (message.to.length !== 0) {
            writer.uint32(34).bytes(message.to);
        }
        if (message.amount.length !== 0) {
            writer.uint32(42).bytes(message.amount);
        }
        if (message.maxFee.length !== 0) {
            writer.uint32(50).bytes(message.maxFee);
        }
        if (message.tips.length !== 0) {
            writer.uint32(58).bytes(message.tips);
        }
        if (message.payload.length !== 0) {
            writer.uint32(66).bytes(message.payload);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0__default["default"].Reader ? input : new _m0__default["default"].Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtoTransaction_Data();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.uint32();
                    break;
                case 2:
                    message.epoch = reader.uint32();
                    break;
                case 3:
                    message.type = reader.uint32();
                    break;
                case 4:
                    message.to = reader.bytes();
                    break;
                case 5:
                    message.amount = reader.bytes();
                    break;
                case 6:
                    message.maxFee = reader.bytes();
                    break;
                case 7:
                    message.tips = reader.bytes();
                    break;
                case 8:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseProtoTransaction_Data();
        message.nonce = (_a = object.nonce) !== null && _a !== void 0 ? _a : 0;
        message.epoch = (_b = object.epoch) !== null && _b !== void 0 ? _b : 0;
        message.type = (_c = object.type) !== null && _c !== void 0 ? _c : 0;
        message.to = (_d = object.to) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.amount = (_e = object.amount) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.maxFee = (_f = object.maxFee) !== null && _f !== void 0 ? _f : new Uint8Array();
        message.tips = (_g = object.tips) !== null && _g !== void 0 ? _g : new Uint8Array();
        message.payload = (_h = object.payload) !== null && _h !== void 0 ? _h : new Uint8Array();
        return message;
    },
};
function createBaseProtoDeployContractAttachment() {
    return { CodeHash: new Uint8Array(), args: [] };
}
const ProtoDeployContractAttachment = {
    encode(message, writer = _m0__default["default"].Writer.create()) {
        if (message.CodeHash.length !== 0) {
            writer.uint32(10).bytes(message.CodeHash);
        }
        for (const v of message.args) {
            writer.uint32(18).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0__default["default"].Reader ? input : new _m0__default["default"].Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtoDeployContractAttachment();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.CodeHash = reader.bytes();
                    break;
                case 2:
                    message.args.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseProtoDeployContractAttachment();
        message.CodeHash = (_a = object.CodeHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.args = ((_b = object.args) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseProtoCallContractAttachment() {
    return { method: '', args: [] };
}
const ProtoCallContractAttachment = {
    encode(message, writer = _m0__default["default"].Writer.create()) {
        if (message.method !== '') {
            writer.uint32(10).string(message.method);
        }
        for (const v of message.args) {
            writer.uint32(18).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0__default["default"].Reader ? input : new _m0__default["default"].Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtoCallContractAttachment();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.method = reader.string();
                    break;
                case 2:
                    message.args.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseProtoCallContractAttachment();
        message.method = (_a = object.method) !== null && _a !== void 0 ? _a : '';
        message.args = ((_b = object.args) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseProtoTerminateContractAttachment() {
    return { args: [] };
}
const ProtoTerminateContractAttachment = {
    encode(message, writer = _m0__default["default"].Writer.create()) {
        for (const v of message.args) {
            writer.uint32(10).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0__default["default"].Reader ? input : new _m0__default["default"].Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtoTerminateContractAttachment();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.args.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseProtoTerminateContractAttachment();
        message.args = ((_a = object.args) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
    },
};
function createBaseProtoStoreToIpfsAttachment() {
    return { cid: new Uint8Array(), size: 0 };
}
const ProtoStoreToIpfsAttachment = {
    encode(message, writer = _m0__default["default"].Writer.create()) {
        if (message.cid.length !== 0) {
            writer.uint32(10).bytes(message.cid);
        }
        if (message.size !== 0) {
            writer.uint32(16).uint32(message.size);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0__default["default"].Reader ? input : new _m0__default["default"].Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtoStoreToIpfsAttachment();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cid = reader.bytes();
                    break;
                case 2:
                    message.size = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseProtoStoreToIpfsAttachment();
        message.cid = (_a = object.cid) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.size = (_b = object.size) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
if (_m0__default["default"].util.Long !== Long__default["default"]) {
    _m0__default["default"].util.Long = Long__default["default"];
    _m0__default["default"].configure();
}

Decimal__default["default"].set({ toExpPos: 10000 });
const DNA_BASE = '1000000000000000000';
function isHexPrefixed(str) {
    return str.slice(0, 2) === '0x';
}
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
function hexToUint8Array(hexString) {
    const str = stripHexPrefix(hexString);
    const arrayBuffer = new Uint8Array(str.length / 2);
    for (let i = 0; i < str.length; i += 2) {
        const byteValue = parseInt(str.substring(i, i + 2), 16);
        arrayBuffer[i / 2] = byteValue;
    }
    return arrayBuffer;
}
function toHexString(byteArray, withPrefix = true) {
    return ((withPrefix ? '0x' : '') +
        Array.from(byteArray, function (byte) {
            return `0${(byte & 0xff).toString(16)}`.slice(-2);
        }).join(''));
}
function floatStringToDna(value) {
    const decimalValue = new Decimal__default["default"](value).mul(new Decimal__default["default"](DNA_BASE)).toString();
    return new BN__default["default"](decimalValue);
}
function dnaToFloatString(value) {
    const bn = new BN__default["default"](value);
    return new Decimal__default["default"](bn.toString(10)).div(new Decimal__default["default"](DNA_BASE)).toString();
}
function calculateGasCost(feePerGas, gas) {
    const bn = new BN__default["default"](feePerGas);
    return bn.mul(new BN__default["default"](gas)).toString();
}

exports.EmbeddedContractType = void 0;
(function (EmbeddedContractType) {
    EmbeddedContractType[EmbeddedContractType["TimeLockContract"] = 1] = "TimeLockContract";
    EmbeddedContractType[EmbeddedContractType["OracleVotingContract"] = 2] = "OracleVotingContract";
    EmbeddedContractType[EmbeddedContractType["OracleLockContract"] = 3] = "OracleLockContract";
    EmbeddedContractType[EmbeddedContractType["RefundableOracleLockContract"] = 4] = "RefundableOracleLockContract";
    EmbeddedContractType[EmbeddedContractType["MultisigContract"] = 5] = "MultisigContract";
})(exports.EmbeddedContractType || (exports.EmbeddedContractType = {}));
exports.ContractArgumentFormat = void 0;
(function (ContractArgumentFormat) {
    ContractArgumentFormat["Default"] = "default";
    ContractArgumentFormat["Byte"] = "byte";
    ContractArgumentFormat["Int8"] = "int8";
    ContractArgumentFormat["Uint64"] = "uint64";
    ContractArgumentFormat["Int64"] = "int64";
    ContractArgumentFormat["String"] = "string";
    ContractArgumentFormat["Bigint"] = "bigint";
    ContractArgumentFormat["Hex"] = "hex";
    ContractArgumentFormat["Dna"] = "dna";
})(exports.ContractArgumentFormat || (exports.ContractArgumentFormat = {}));

Decimal__default["default"].set({ toExpPos: 10000 });
function argumentFromBytes(format, index, bytes) {
    if (bytes.length === 0) {
        return {
            format,
            index,
            value: null,
        };
    }
    switch (format) {
        case 'byte': {
            return {
                format: exports.ContractArgumentFormat.Byte,
                index: index,
                value: bytes[0],
            };
        }
        case 'int8': {
            return {
                format: exports.ContractArgumentFormat.Int8,
                index: index,
                value: bytes[0],
            };
        }
        case 'uint64': {
            const res = Buffer.from(bytes).readBigUint64LE();
            return {
                format: exports.ContractArgumentFormat.Uint64,
                index: index,
                value: res.toString(10),
            };
        }
        case 'int64': {
            const res = Buffer.from(bytes).readBigInt64LE();
            return {
                format: exports.ContractArgumentFormat.Int64,
                index: index,
                value: res.toString(10),
            };
        }
        case 'string': {
            const res = utf8ByteArrayToString(bytes);
            return {
                format: exports.ContractArgumentFormat.String,
                index: index,
                value: res,
            };
        }
        case 'bigint': {
            const res = new BN__default["default"](bytes);
            return {
                format: exports.ContractArgumentFormat.Bigint,
                index: index,
                value: res.toString(10),
            };
        }
        case 'hex': {
            return {
                format: exports.ContractArgumentFormat.Hex,
                index: index,
                value: toHexString(bytes),
            };
        }
        case 'dna': {
            const bn = new BN__default["default"](bytes);
            return {
                format: exports.ContractArgumentFormat.Dna,
                index: index,
                value: dnaToFloatString(bn),
            };
        }
        default: {
            return {
                format: exports.ContractArgumentFormat.Default,
                index: index,
                value: toHexString(bytes),
            };
        }
    }
}
function argumentsFromBytes(formats, bytes) {
    return formats.map((format, idx) => argumentFromBytes(format, idx, bytes[idx] || new Uint8Array()));
}
function argumentToBytes(data) {
    try {
        switch (data.format) {
            case 'byte': {
                const val = parseInt(data.value, 10);
                if (val >= 0 && val <= 255) {
                    return new Uint8Array([val]);
                }
                throw new Error('invalid byte value');
            }
            case 'int8': {
                const val = parseInt(data.value, 10);
                if (val >= 0 && val <= 255) {
                    return new Uint8Array([val]);
                }
                throw new Error('invalid int8 value');
            }
            case 'uint64': {
                const res = new BN__default["default"](data.value);
                if (res.isNeg())
                    throw new Error('invalid uint64 value');
                const buf = Buffer.alloc(8);
                buf.writeBigUint64LE(BigInt(res.toString()));
                return new Uint8Array(buf);
            }
            case 'int64': {
                const buf = Buffer.alloc(8);
                buf.writeBigInt64LE(BigInt(new BN__default["default"](data.value).toString()));
                return new Uint8Array(buf);
            }
            case 'string': {
                return stringToUtf8ByteArray(data.value);
            }
            case 'bigint': {
                return new Uint8Array(new BN__default["default"](data.value).toArray());
            }
            case 'hex': {
                return new Uint8Array([...hexToUint8Array(data.value)]);
            }
            case 'dna': {
                return new Uint8Array(floatStringToDna(data.value).toArray());
            }
            default: {
                return new Uint8Array([...hexToUint8Array(data.value)]);
            }
        }
    }
    catch (e) {
        throw new Error(`cannot parse ${data.format} at index ${data.index}: ${e === null || e === void 0 ? void 0 : e.message}`);
    }
}
function argumentsToBytes(args) {
    const maxIndex = Math.max(...args.map((x) => x.index));
    const result = new Array(maxIndex).fill(null);
    args.forEach((element) => {
        result[element.index] = argumentToBytes(element);
    });
    return result;
}
/**
 * Converts a JS string to a UTF-8 "byte" array.
 * @param {string} str 16-bit unicode string.
 * @return {!Uint8Array} UTF-8 byte array.
 */
function stringToUtf8ByteArray(str) {
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if ((c & 0xfc00) == 0xd800 &&
            i + 1 < str.length &&
            (str.charCodeAt(i + 1) & 0xfc00) == 0xdc00) {
            // Surrogate Pair
            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return new Uint8Array(out);
}
/**
 * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.
 * @param {Uint8Array} bytes UTF-8 byte array.
 * @return {string} 16-bit Unicode string.
 */
function utf8ByteArrayToString(bytes) {
    const out = [];
    let pos = 0;
    let c = 0;
    while (pos < bytes.length) {
        const c1 = bytes[pos++] || 0;
        if (c1 < 128) {
            out[c++] = String.fromCharCode(c1);
        }
        else if (c1 > 191 && c1 < 224) {
            const c2 = bytes[pos++] || 0;
            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
        }
        else if (c1 > 239 && c1 < 365) {
            // Surrogate Pair
            const c2 = bytes[pos++] || 0;
            const c3 = bytes[pos++] || 0;
            const c4 = bytes[pos++] || 0;
            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -
                0x10000;
            out[c++] = String.fromCharCode(0xd800 + (u >> 10));
            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
        }
        else {
            const c2 = bytes[pos++] || 0;
            const c3 = bytes[pos++] || 0;
            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
        }
    }
    return out.join('');
}

class DeployContractAttachment {
    constructor(init) {
        this._codeHash = (init === null || init === void 0 ? void 0 : init.codeHash) || 0;
        this._args = (init === null || init === void 0 ? void 0 : init.args) || [];
    }
    set codeHash(codeHash) {
        this._codeHash = codeHash;
    }
    get codeHash() {
        return this._codeHash;
    }
    set args(args) {
        this._args = args;
    }
    get args() {
        return this._args;
    }
    getArgs(formats) {
        return argumentsFromBytes(formats, this._args);
    }
    setArgs(args) {
        this._args = argumentsToBytes(args);
    }
    fromBytes(bytes) {
        const protoAttachment = ProtoDeployContractAttachment.decode(bytes);
        this._codeHash = protoAttachment.CodeHash[0] || 0;
        this._args = protoAttachment.args;
        return this;
    }
    toBytes() {
        const attachment = ProtoDeployContractAttachment.fromPartial({
            CodeHash: new Uint8Array([this._codeHash]),
            args: this._args.map((x) => x || new Uint8Array()),
        });
        return ProtoDeployContractAttachment.encode(attachment).finish();
    }
}

class CallContractAttachment {
    constructor(init) {
        this._method = (init === null || init === void 0 ? void 0 : init.method) || '';
        this._args = (init === null || init === void 0 ? void 0 : init.args) || [];
    }
    set method(method) {
        this._method = method;
    }
    get method() {
        return this._method;
    }
    set args(args) {
        this._args = args;
    }
    get args() {
        return this._args;
    }
    getArgs(formats) {
        return argumentsFromBytes(formats, this._args);
    }
    setArgs(args) {
        this._args = argumentsToBytes(args);
        return this;
    }
    fromBytes(bytes) {
        const protoAttachment = ProtoCallContractAttachment.decode(bytes);
        this._method = protoAttachment.method;
        this._args = protoAttachment.args;
        return this;
    }
    toBytes() {
        const attachment = ProtoCallContractAttachment.fromPartial({
            method: this._method,
            args: this._args.map((x) => x || new Uint8Array()),
        });
        return ProtoCallContractAttachment.encode(attachment).finish();
    }
}

class TerminateContractAttachment {
    constructor(init) {
        this._args = (init === null || init === void 0 ? void 0 : init.args) || [];
    }
    set args(args) {
        this._args = args;
    }
    get args() {
        return this._args;
    }
    getArgs(formats) {
        return argumentsFromBytes(formats, this._args);
    }
    setArgs(args) {
        this._args = argumentsToBytes(args);
    }
    fromBytes(bytes) {
        const protoAttachment = ProtoTerminateContractAttachment.decode(bytes);
        this._args = protoAttachment.args;
        return this;
    }
    toBytes() {
        const attachment = ProtoTerminateContractAttachment.fromPartial({
            args: this._args.map((x) => x || new Uint8Array()),
        });
        return ProtoTerminateContractAttachment.encode(attachment).finish();
    }
}

function getKeyArray(key) {
    return typeof key === 'string' ? hexToUint8Array(key) : new Uint8Array(key);
}
function privateKeyToPublicKey(key, withPrefix = false) {
    const pubKey = secp256k1__default["default"].publicKeyCreate(getKeyArray(key), false);
    return toHexString(pubKey, withPrefix);
}
function publicKeyToAddress(publicKey, withPrefix = true) {
    return toHexString(sha3__default["default"].keccak_256.array(getKeyArray(publicKey).slice(1)).slice(12), withPrefix);
}
function privateKeyToAddress(key, withPrefix = true) {
    if (!key) {
        return '0x0000000000000000000000000000000000000000';
    }
    const pubKey = secp256k1__default["default"].publicKeyCreate(getKeyArray(key), false);
    return publicKeyToAddress(pubKey, withPrefix);
}
function sender(data, signature, withPrefix = true) {
    const hash = sha3__default["default"].keccak_256.array(data);
    const pubKey = secp256k1__default["default"].ecdsaRecover(new Uint8Array(signature).slice(0, -1), Number(signature[signature.length - 1]), new Uint8Array(hash), false);
    return publicKeyToAddress(pubKey, withPrefix);
}
function sign(data, key) {
    const hash = sha3__default["default"].keccak_256.array(data);
    const { signature, recid } = secp256k1__default["default"].ecdsaSign(new Uint8Array(hash), typeof key === 'string' ? hexToUint8Array(key) : new Uint8Array(key));
    return new Uint8Array([...signature, recid]);
}

class StoreToIpfsAttachment {
    constructor(init) {
        this._size = (init === null || init === void 0 ? void 0 : init.size) || 0;
        this._cid = (init === null || init === void 0 ? void 0 : init.cid) || new Uint8Array();
    }
    set size(size) {
        this._size = size;
    }
    get size() {
        return this._size;
    }
    set cid(cid) {
        this._cid = cid;
    }
    get cid() {
        return this._cid;
    }
    fromBytes(bytes) {
        const protoAttachment = ProtoStoreToIpfsAttachment.decode(bytes);
        this._cid = protoAttachment.cid;
        this._size = protoAttachment.size;
        return this;
    }
    toBytes() {
        const attachment = ProtoStoreToIpfsAttachment.fromPartial({
            cid: this._cid,
            size: this._size,
        });
        return ProtoStoreToIpfsAttachment.encode(attachment).finish();
    }
}

exports.TransactionType = void 0;
(function (TransactionType) {
    TransactionType[TransactionType["SendTx"] = 0] = "SendTx";
    TransactionType[TransactionType["ActivationTx"] = 1] = "ActivationTx";
    TransactionType[TransactionType["InviteTx"] = 2] = "InviteTx";
    TransactionType[TransactionType["KillTx"] = 3] = "KillTx";
    TransactionType[TransactionType["SubmitFlipTx"] = 4] = "SubmitFlipTx";
    TransactionType[TransactionType["SubmitAnswersHashTx"] = 5] = "SubmitAnswersHashTx";
    TransactionType[TransactionType["SubmitShortAnswersTx"] = 6] = "SubmitShortAnswersTx";
    TransactionType[TransactionType["SubmitLongAnswersTx"] = 7] = "SubmitLongAnswersTx";
    TransactionType[TransactionType["EvidenceTx"] = 8] = "EvidenceTx";
    TransactionType[TransactionType["OnlineStatusTx"] = 9] = "OnlineStatusTx";
    TransactionType[TransactionType["KillInviteeTx"] = 10] = "KillInviteeTx";
    TransactionType[TransactionType["ChangeGodAddressTx"] = 11] = "ChangeGodAddressTx";
    TransactionType[TransactionType["BurnTx"] = 12] = "BurnTx";
    TransactionType[TransactionType["ChangeProfileTx"] = 13] = "ChangeProfileTx";
    TransactionType[TransactionType["DeleteFlipTx"] = 14] = "DeleteFlipTx";
    TransactionType[TransactionType["DeployContractTx"] = 15] = "DeployContractTx";
    TransactionType[TransactionType["CallContractTx"] = 16] = "CallContractTx";
    TransactionType[TransactionType["TerminateContractTx"] = 17] = "TerminateContractTx";
    TransactionType[TransactionType["DelegateTx"] = 18] = "DelegateTx";
    TransactionType[TransactionType["UndelegateTx"] = 19] = "UndelegateTx";
    TransactionType[TransactionType["KillDelegatorTx"] = 20] = "KillDelegatorTx";
    TransactionType[TransactionType["StoreToIpfsTx"] = 21] = "StoreToIpfsTx";
})(exports.TransactionType || (exports.TransactionType = {}));
class Transaction {
    constructor(init) {
        var _a, _b, _c, _d, _e, _f, _g;
        this._nonce = 0;
        this._epoch = 0;
        this._type = 0;
        this._to = null;
        this._amount = null;
        this._maxFee = null;
        this._tips = null;
        this._payload = null;
        this._signature = null;
        this.nonce = (_a = init === null || init === void 0 ? void 0 : init.nonce) !== null && _a !== void 0 ? _a : 0;
        this.epoch = (_b = init === null || init === void 0 ? void 0 : init.epoch) !== null && _b !== void 0 ? _b : 0;
        this.type = (_c = init === null || init === void 0 ? void 0 : init.type) !== null && _c !== void 0 ? _c : 0;
        this.to = (_d = init === null || init === void 0 ? void 0 : init.to) !== null && _d !== void 0 ? _d : null;
        this.amount = (_e = init === null || init === void 0 ? void 0 : init.amount) !== null && _e !== void 0 ? _e : null;
        this.maxFee = (_f = init === null || init === void 0 ? void 0 : init.maxFee) !== null && _f !== void 0 ? _f : null;
        this.tips = (_g = init === null || init === void 0 ? void 0 : init.tips) !== null && _g !== void 0 ? _g : null;
        this.payload = (init === null || init === void 0 ? void 0 : init.payload) ? new Uint8Array(init.payload) : null;
    }
    set nonce(nonce) {
        this._nonce = nonce;
    }
    get nonce() {
        return this._nonce;
    }
    set epoch(epoch) {
        this._epoch = epoch;
    }
    get epoch() {
        return this._epoch;
    }
    set type(type) {
        this._type = type;
    }
    get type() {
        return this._type;
    }
    set to(to) {
        if (to === null)
            this._to = null;
        else if (to instanceof Uint8Array)
            this._to = to;
        else
            this._to = hexToUint8Array(to);
    }
    get to() {
        return this._to && this._to.length > 0 ? toHexString(this._to, true) : null;
    }
    set amount(amount) {
        this._amount = amount !== null ? new BN__default["default"](amount) : null;
    }
    get amount() {
        return this._amount;
    }
    set maxFee(maxFee) {
        this._maxFee = maxFee !== null ? new BN__default["default"](maxFee) : null;
    }
    get maxFee() {
        return this._maxFee;
    }
    set tips(tips) {
        this._tips = tips !== null ? new BN__default["default"](tips) : null;
    }
    get tips() {
        return this._tips;
    }
    set payload(payload) {
        this._payload = payload;
    }
    get payload() {
        return this._payload ? new Uint8Array(this._payload) : null;
    }
    get signature() {
        return this._signature;
    }
    get hash() {
        return Buffer.from(sha3__default["default"].keccak_256.array(this.toBytes())).toString('hex');
    }
    get sender() {
        try {
            if (!this._signature || this._signature.length === 0)
                return null;
            const data = ProtoTransaction_Data.encode(this._createProtoTxData()).finish();
            return sender(data, this._signature, true);
        }
        catch (_a) {
            return null;
        }
    }
    get gas() {
        const bytes = this.toBytes();
        let size = bytes.length;
        if (!this._signature || this._signature.length === 0)
            size += 67;
        if (this.type === exports.TransactionType.DeleteFlipTx)
            size += 1024 * 120;
        if (this.type === exports.TransactionType.StoreToIpfsTx) {
            const maxSize = 1024 * 1024;
            try {
                if (this.payload) {
                    const attachment = new StoreToIpfsAttachment().fromBytes(this.payload);
                    size += attachment.size * 0.2 || maxSize;
                }
                else {
                    size += maxSize;
                }
            }
            catch (e) {
                size += maxSize;
            }
        }
        return ~~size * 10;
    }
    static fromHex(hex) {
        return new Transaction().fromHex(hex);
    }
    static fromBytes(bytes) {
        return new Transaction().fromBytes(bytes);
    }
    fromHex(hex) {
        return this.fromBytes(hexToUint8Array(hex));
    }
    fromBytes(bytes) {
        const protoTx = ProtoTransaction.decode(bytes);
        const protoTxData = protoTx.data;
        if (protoTxData) {
            this.nonce = protoTxData.nonce;
            this.epoch = protoTxData.epoch;
            this.type = protoTxData.type;
            this.to = protoTxData.to;
            this.amount = protoTxData.amount;
            this.maxFee = protoTxData.maxFee;
            this.tips = protoTxData.tips;
            this.payload = protoTxData.payload;
        }
        this._signature = protoTx.signature;
        return this;
    }
    fromJson(jsonTx) {
        function getTxType(type) {
            var _a, _b;
            if (!(type === null || type === void 0 ? void 0 : type.length))
                return exports.TransactionType.SendTx;
            const stringType = ((_a = type[0]) === null || _a === void 0 ? void 0 : _a.toUpperCase()) + type.slice(1) + 'Tx';
            return ((((_b = Object.entries(exports.TransactionType).find(([key]) => key === stringType)) === null || _b === void 0 ? void 0 : _b[1]) || exports.TransactionType.SendTx));
        }
        this.nonce = jsonTx.nonce;
        this.epoch = jsonTx.epoch;
        this.type = getTxType(jsonTx.type);
        this.to = jsonTx.to;
        this.amount = floatStringToDna(jsonTx.amount);
        this.maxFee = floatStringToDna(jsonTx.maxFee);
        this.tips = floatStringToDna(jsonTx.tips);
        this.payload = hexToUint8Array(jsonTx.payload);
        return this;
    }
    toBytes() {
        var _a;
        const tx = ProtoTransaction.fromPartial({
            data: this._createProtoTxData(),
            signature: (_a = this._signature) !== null && _a !== void 0 ? _a : new Uint8Array(),
        });
        return ProtoTransaction.encode(tx).finish();
    }
    sign(key) {
        const data = ProtoTransaction_Data.encode(this._createProtoTxData()).finish();
        this._signature = sign(data, key);
        return this;
    }
    toHex(withPrefix = true) {
        return toHexString(this.toBytes(), withPrefix);
    }
    _createProtoTxData() {
        var _a, _b;
        return ProtoTransaction_Data.fromPartial({
            epoch: this._epoch,
            nonce: this._nonce,
            type: this._type,
            to: (_a = this._to) !== null && _a !== void 0 ? _a : new Uint8Array(),
            amount: new Uint8Array(!this._amount || this._amount.isZero() ? [] : this._amount.toArray()),
            maxFee: new Uint8Array(!this._maxFee || this._maxFee.isZero() ? [] : this._maxFee.toArray()),
            tips: new Uint8Array(!this._tips || this._tips.isZero() ? [] : this._tips.toArray()),
            payload: (_b = this._payload) !== null && _b !== void 0 ? _b : new Uint8Array(),
        });
    }
}

class JsonBlock {
    constructor(coinbase, hash, parentHash, height, root, identityRoot, ipfsCid, transactions, flags, isEmpty, offlineAddress) {
        this.coinbase = coinbase;
        this.hash = hash;
        this.parentHash = parentHash;
        this.height = height;
        this.root = root;
        this.identityRoot = identityRoot;
        this.ipfsCid = ipfsCid;
        this.transactions = transactions;
        this.flags = flags;
        this.isEmpty = isEmpty;
        this.offlineAddress = offlineAddress;
    }
}
class JsonTransaction {
    constructor(hash, type, from, to, amount, tips, maxFee, nonce, epoch, payload, blockHash, usedFee, timestamp) {
        this.hash = hash;
        this.type = type;
        this.from = from;
        this.to = to;
        this.amount = amount;
        this.tips = tips;
        this.maxFee = maxFee;
        this.nonce = nonce;
        this.epoch = epoch;
        this.payload = payload;
        this.blockHash = blockHash;
        this.usedFee = usedFee;
        this.timestamp = timestamp;
    }
}
class JsonReceipt {
    constructor(contract, method, success, gasUsed, txHash, error, gasCost, txFee) {
        this.contract = contract;
        this.method = method;
        this.success = success;
        this.gasUsed = gasUsed;
        this.txHash = txHash;
        this.error = error;
        this.gasCost = gasCost;
        this.txFee = txFee;
    }
}
class JsonBalance {
    constructor(stake, balance, nonce, mempoolNonce) {
        this.stake = stake;
        this.balance = balance;
        this.nonce = nonce;
        this.mempoolNonce = mempoolNonce;
    }
}
class JsonIdentity {
    constructor(address, profileHash, stake, invites, age, state, pubkey, requiredFlips, availableFlips, flipKeyWordPairs, madeFlips, totalQualifiedFlips, totalShortFlipPoints, flips, online, generation, code, invitees, penalty, lastValidationFlags, delegatee, delegationEpoch, delegationNonce, isPool, inviter, shardId) {
        this.address = address;
        this.profileHash = profileHash;
        this.stake = stake;
        this.invites = invites;
        this.age = age;
        this.state = state;
        this.pubkey = pubkey;
        this.requiredFlips = requiredFlips;
        this.availableFlips = availableFlips;
        this.flipKeyWordPairs = flipKeyWordPairs;
        this.madeFlips = madeFlips;
        this.totalQualifiedFlips = totalQualifiedFlips;
        this.totalShortFlipPoints = totalShortFlipPoints;
        this.flips = flips;
        this.online = online;
        this.generation = generation;
        this.code = code;
        this.invitees = invitees;
        this.penalty = penalty;
        this.lastValidationFlags = lastValidationFlags;
        this.delegatee = delegatee;
        this.delegationEpoch = delegationEpoch;
        this.delegationNonce = delegationNonce;
        this.isPool = isPool;
        this.inviter = inviter;
        this.shardId = shardId;
    }
}
class JsonEpoch {
    constructor(startBlock, epoch, nextValidation, currentPeriod) {
        this.startBlock = startBlock;
        this.epoch = epoch;
        this.nextValidation = nextValidation;
        this.currentPeriod = currentPeriod;
    }
}
class JsonIterateMapItem {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}
class JsonIterateMap {
    constructor(items, continuationToken) {
        this.items = items;
        this.continuationToken = continuationToken;
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function createAxiosInstance(url, apiKey) {
    const res = axios__default["default"].create({ baseURL: url });
    res.interceptors.request.use(function (config) {
        config.data.key = apiKey;
        return config;
    });
    return res;
}

class BaseProvider {
    constructor(httpProvider) {
        this._httpProvider = httpProvider;
    }
    doRequest(obj) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!obj.id)
                    obj.id = 1;
                const { data } = yield this._httpProvider.post('/', obj);
                const { result, error } = data;
                if (error)
                    throw new Error(error.message);
                return result;
            }
            catch (e) {
                if (axios__default["default"].isAxiosError(e)) {
                    if (e.response) {
                        throw new Error(e.response.data);
                    }
                    else if (e.request) {
                        throw new Error('node is unavailable');
                    }
                    else
                        throw new Error(e.message);
                }
                else {
                    throw e;
                }
            }
        });
    }
}

class BcnProvider extends BaseProvider {
    static create(url, apiKey) {
        return new BcnProvider(createAxiosInstance(url, apiKey));
    }
    constructor(httpProvider) {
        super(httpProvider);
    }
    buildTx(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = data;
            if (data.payload)
                params.payload = toHexString(data.payload);
            params.useProto = true;
            const result = yield this.doRequest({
                method: 'bcn_getRawTx',
                params: [params],
            });
            return new Transaction().fromHex(result);
        });
    }
    sendTx(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'bcn_sendRawTx',
                params: [tx.toHex(true)],
            });
            return result;
        });
    }
    estimateTx(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'bcn_estimateRawTx',
                params: [tx.toHex(true)],
            });
            return result;
        });
    }
    blockAt(num) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'bcn_blockAt',
                params: [num],
            });
            return result;
        });
    }
    block(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'bcn_block',
                params: [hash],
            });
            return result;
        });
    }
    lastBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'bcn_lastBlock',
                params: [],
            });
            return result;
        });
    }
    transaction(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'bcn_transaction',
                params: [hash],
            });
            return result;
        });
    }
    receipt(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'bcn_txReceipt',
                params: [hash],
            });
            return result;
        });
    }
    feePerGas() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'bcn_feePerGas',
                params: [],
            });
            return result;
        });
    }
}

class ContractProvider extends BaseProvider {
    static create(url, apiKey) {
        return new ContractProvider(createAxiosInstance(url, apiKey));
    }
    constructor(httpProvider) {
        super(httpProvider);
    }
    readData(address, key, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'contract_readData',
                params: [address, key, format],
            });
            return result;
        });
    }
    readonlyCall(address, method, format, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'contract_readonlyCall',
                params: [{ contract: address, method, format, args }],
            });
            return result;
        });
    }
    readMap(address, mapName, key, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'contract_readMap',
                params: [address, mapName, key, format],
            });
            return result;
        });
    }
    iterateMap(address, mapName, keyFormat, valueFormat, limit = 10, continuationToken = '0x') {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'contract_iterateMap',
                params: [
                    address,
                    mapName,
                    continuationToken,
                    keyFormat,
                    valueFormat,
                    limit,
                ],
            });
            return result;
        });
    }
}

class DnaProvider extends BaseProvider {
    static create(url, apiKey) {
        return new DnaProvider(createAxiosInstance(url, apiKey));
    }
    constructor(httpProvider) {
        super(httpProvider);
    }
    balance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'dna_getBalance',
                params: [address],
            });
            return result;
        });
    }
    identity(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'dna_identity',
                params: address ? [address] : [],
            });
            return result;
        });
    }
    epoch() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.doRequest({
                method: 'dna_epoch',
                params: [],
            });
            return result;
        });
    }
}

class IdenaProvider extends BaseProvider {
    constructor(httpProvider) {
        super(httpProvider);
        this._bcnProvider = new BcnProvider(httpProvider);
        this._contractProvider = new ContractProvider(httpProvider);
        this._dnaProvider = new DnaProvider(httpProvider);
    }
    get Blockchain() {
        return this._bcnProvider;
    }
    get Contract() {
        return this._contractProvider;
    }
    get Dna() {
        return this._dnaProvider;
    }
    static create(url, apiKey) {
        return new IdenaProvider(createAxiosInstance(url, apiKey));
    }
}

exports.BcnProvider = BcnProvider;
exports.CallContractAttachment = CallContractAttachment;
exports.ContractProvider = ContractProvider;
exports.DNA_BASE = DNA_BASE;
exports.DeployContractAttachment = DeployContractAttachment;
exports.DnaProvider = DnaProvider;
exports.IdenaProvider = IdenaProvider;
exports.JsonBalance = JsonBalance;
exports.JsonBlock = JsonBlock;
exports.JsonEpoch = JsonEpoch;
exports.JsonIdentity = JsonIdentity;
exports.JsonIterateMap = JsonIterateMap;
exports.JsonIterateMapItem = JsonIterateMapItem;
exports.JsonReceipt = JsonReceipt;
exports.JsonTransaction = JsonTransaction;
exports.TerminateContractAttachment = TerminateContractAttachment;
exports.Transaction = Transaction;
exports.argumentFromBytes = argumentFromBytes;
exports.argumentToBytes = argumentToBytes;
exports.argumentsFromBytes = argumentsFromBytes;
exports.argumentsToBytes = argumentsToBytes;
exports.calculateGasCost = calculateGasCost;
exports.dnaToFloatString = dnaToFloatString;
exports.floatStringToDna = floatStringToDna;
exports.hexToUint8Array = hexToUint8Array;
exports.privateKeyToAddress = privateKeyToAddress;
exports.privateKeyToPublicKey = privateKeyToPublicKey;
exports.publicKeyToAddress = publicKeyToAddress;
exports.sender = sender;
exports.sign = sign;
exports.stripHexPrefix = stripHexPrefix;
exports.toHexString = toHexString;
//# sourceMappingURL=index.cjs.map
